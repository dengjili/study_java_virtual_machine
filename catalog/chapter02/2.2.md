# 运行时数据区域

java虚拟机根据用途的不同，将内存划分成以下几个区域。

<img src="https://raw.githubusercontent.com/dengjili/study_java_virtual_machine/master/picture/chapter02/2.2/1.png" width = "400" height = "300" div align=center />

## 程序计数器

1. 指向当前线程执行的字节码地址，程序的控制，如：循环、跳转等，线程的恢复都依赖于程序计数器来完成。
2. 由于cpu选择线程是轮换执行的，所以每个线程都需要记住当前程序执行指令的地址，以便于轮换到自己的时候，切换到上一次执行的位置，所有每个线程的程序计数器独立的，也就是线程独立的内存，也是上图中说明的隔离的数据区。
3. 特殊说明，如果执行native方法，程序计数器值为空。
4. 此内存区域在java虚拟机中是没有`OutofMemoryError`定义

## java虚拟机栈

1. java虚拟机栈也是线程独立的内存，生命周期与线程相同。java虚拟机栈是对应java方法的内存模型，每个方法执行都会创建栈帧，栈帧存储局部变量表、操作数栈、动态链接、方法出口等。对应下图关系

<img src="https://raw.githubusercontent.com/dengjili/study_java_virtual_machine/master/picture/chapter02/2.2/2.png" width = "600" height = "600" div align=center />

2. 局部变量表,存储java的基本数据类型（boolean、byte、char、short、int、long、float、double）和对象引用类型。`long、double`会占用两个局部变量表空间，其余的数据类型都只占用一个。由于局部变量表存储的都是已知大小的数据类型，则局部变量表所需要的内存空间，在编译期间则可完全确定。
3. 此区域在java虚拟机中定义了两种异常情况

    * 如果线程请求的栈深度大于虚拟机允许的深度大于虚拟机允许的深度，将抛出StackOverflowError异常。比如平时写代码不小心递归调用，虚拟机不断地创建栈帧，最终栈深度过大。
    * 如果虚拟机栈可以动态扩展，如果扩展的时候无法申请的足够的内存，将抛出OutofMemoryError异常。

## 本地方法栈

* 本地方法栈与java虚拟机栈作用类型，只是提供不同的面向服务而已，虚拟机栈是为虚拟机提供java方法服务。本地方法栈提供的native方法服务，分别对应java中的普通方法和native方法
* 本地方法栈也会抛出StackOverflowError异常或抛出OutofMemoryError异常

## java堆

1. java堆是java虚拟机管理的最大的内存，而这块内存是所有线程共享的，也就是这上面的对象可能会出现线程不安全的情况，也就是我们平时所说的并发问题。一般来说，对象实例和数组（数组也是一种特殊的对象）都是在堆上分配的。
2. 为了更好的对内存进行分配和回收，我们对堆进行了一些划分。比如：新生代、老年代。或者其他划分为Eden空间、From Survivor、To Survivor空间等。虽然划分不同，但是目的都是为了更好地分配和回收内存。
3. java堆分配可以是物理上不连续的内存空间，只要逻辑连续即可。大多数虚拟机我们可以通过参数`-xms -xmx`来控制堆空间大小分配，如果堆中没有内存可分配，而且堆无法扩展，将会抛出`OutofMemoryError`异常

## 方法区
1. 方法区是所有线程共享的，和java堆一致。用于存储已被虚拟机加载的类信息、常量（`final`）、静态变量（`static`）、即是编译器编译后的代码等数据。
2. 在虚拟机HotSpot中，方法区被称为了`永久代`，仅仅是因为将GC分代扩展到了方法区，这样就可以将方法区内存管理像管理堆内存一样，统一管理而已，永久代可通过`-XX:MaxPermSize`设置上限。目前Hotspot开始放弃永久代的设计，将采用native memory来实现方法区。在jdk1.7中，已经将字符串常量池移出。
3. 方法区也与java堆一样，运行物理空间不连续，逻辑连续即可。也可以选择内存固定大小或者可以扩展。当方法区无法分配内存时候，将会抛出`OutofMemoryError`异常

## 运行时常量池
1. 运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量与符号的引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
2. 运行时常量池相对于Class文件的常量池重要不同是具有动态性，即运行时常量池中的常量不一定只在编译期产生，运行期间也可以产生，如：String类的intern方法
3. 由于运行时常量池也是方法区的一部分，那么当运行时常量池无法分配内存时候，将会抛出`OutofMemoryError`异常
## 直接内存
1. 直接内存并不是java虚拟机的一部分，但是这部分内存也会是频繁的使用，甚至会发生OutofMemoryError异常
2. java 1.4中引入了nio，基于通道和缓冲区技术的新I/O方式，该方式可以运行直接使用native方法直接分配堆外内存，然后将这堆内存赋值给java的DirectByteBuffer对象，避免了java堆和native堆赋值数据，特定场景可以显著提高性能。
3. 如果分配内存过大，也会抛出`OutofMemoryError`异常。